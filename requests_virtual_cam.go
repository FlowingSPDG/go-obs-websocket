// Code generated by protocol.py DO NOT EDIT
// Generator can be found at https://github.com/FlowingSPDG/go-obs-websocket/blob/master/codegen/protocol.py

package obsws

import (
	"errors"
	"time"
)

// GetVirtualCamStatusRequest : Get current virtual cam status.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getvirtualcamstatus
type GetVirtualCamStatusRequest struct {
	_request `json:",squash"`
	response chan GetVirtualCamStatusResponse
}

// NewGetVirtualCamStatusRequest returns a new GetVirtualCamStatusRequest.
func NewGetVirtualCamStatusRequest() GetVirtualCamStatusRequest {
	return GetVirtualCamStatusRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "GetVirtualCamStatus",
			err:   make(chan error, 1),
		},
		make(chan GetVirtualCamStatusResponse, 1),
	}
}

// Send sends the request.
func (r *GetVirtualCamStatusRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetVirtualCamStatusResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetVirtualCamStatusRequest) Receive() (GetVirtualCamStatusResponse, error) {
	if !r.sent {
		return GetVirtualCamStatusResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetVirtualCamStatusResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetVirtualCamStatusResponse{}, err
		case <-time.After(receiveTimeout):
			return GetVirtualCamStatusResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetVirtualCamStatusRequest) SendReceive(c Client) (GetVirtualCamStatusResponse, error) {
	if err := r.Send(c); err != nil {
		return GetVirtualCamStatusResponse{}, err
	}
	return r.Receive()
}

// GetVirtualCamStatusResponse : Response for GetVirtualCamStatusRequest.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#getvirtualcamstatus
type GetVirtualCamStatusResponse struct {
	// Current virtual camera status.
	// Required: Yes.
	IsVirtualCam bool `json:"isVirtualCam"`
	// Time elapsed since virtual cam started (only present if virtual cam currently active).
	// Required: No.
	VirtualCamTimecode string `json:"virtualCamTimecode"`
	_response          `json:",squash"`
}

// StartStopVirtualCamRequest : Toggle virtual cam on or off (depending on the current virtual cam state).
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#startstopvirtualcam
type StartStopVirtualCamRequest struct {
	_request `json:",squash"`
	response chan StartStopVirtualCamResponse
}

// NewStartStopVirtualCamRequest returns a new StartStopVirtualCamRequest.
func NewStartStopVirtualCamRequest() StartStopVirtualCamRequest {
	return StartStopVirtualCamRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "StartStopVirtualCam",
			err:   make(chan error, 1),
		},
		make(chan StartStopVirtualCamResponse, 1),
	}
}

// Send sends the request.
func (r *StartStopVirtualCamRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp StartStopVirtualCamResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r StartStopVirtualCamRequest) Receive() (StartStopVirtualCamResponse, error) {
	if !r.sent {
		return StartStopVirtualCamResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return StartStopVirtualCamResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return StartStopVirtualCamResponse{}, err
		case <-time.After(receiveTimeout):
			return StartStopVirtualCamResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r StartStopVirtualCamRequest) SendReceive(c Client) (StartStopVirtualCamResponse, error) {
	if err := r.Send(c); err != nil {
		return StartStopVirtualCamResponse{}, err
	}
	return r.Receive()
}

// StartStopVirtualCamResponse : Response for StartStopVirtualCamRequest.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#startstopvirtualcam
type StartStopVirtualCamResponse struct {
	_response `json:",squash"`
}

// StartVirtualCamRequest : Start virtual cam.
// Will return an `error` if virtual cam is already active.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#startvirtualcam
type StartVirtualCamRequest struct {
	_request `json:",squash"`
	response chan StartVirtualCamResponse
}

// NewStartVirtualCamRequest returns a new StartVirtualCamRequest.
func NewStartVirtualCamRequest() StartVirtualCamRequest {
	return StartVirtualCamRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "StartVirtualCam",
			err:   make(chan error, 1),
		},
		make(chan StartVirtualCamResponse, 1),
	}
}

// Send sends the request.
func (r *StartVirtualCamRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp StartVirtualCamResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r StartVirtualCamRequest) Receive() (StartVirtualCamResponse, error) {
	if !r.sent {
		return StartVirtualCamResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return StartVirtualCamResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return StartVirtualCamResponse{}, err
		case <-time.After(receiveTimeout):
			return StartVirtualCamResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r StartVirtualCamRequest) SendReceive(c Client) (StartVirtualCamResponse, error) {
	if err := r.Send(c); err != nil {
		return StartVirtualCamResponse{}, err
	}
	return r.Receive()
}

// StartVirtualCamResponse : Response for StartVirtualCamRequest.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#startvirtualcam
type StartVirtualCamResponse struct {
	_response `json:",squash"`
}

// StopVirtualCamRequest : Stop virtual cam.
// Will return an `error` if virtual cam is not active.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#stopvirtualcam
type StopVirtualCamRequest struct {
	_request `json:",squash"`
	response chan StopVirtualCamResponse
}

// NewStopVirtualCamRequest returns a new StopVirtualCamRequest.
func NewStopVirtualCamRequest() StopVirtualCamRequest {
	return StopVirtualCamRequest{
		_request{
			ID_:   GetMessageID(),
			Type_: "StopVirtualCam",
			err:   make(chan error, 1),
		},
		make(chan StopVirtualCamResponse, 1),
	}
}

// Send sends the request.
func (r *StopVirtualCamRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.SendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp StopVirtualCamResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r StopVirtualCamRequest) Receive() (StopVirtualCamResponse, error) {
	if !r.sent {
		return StopVirtualCamResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return StopVirtualCamResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return StopVirtualCamResponse{}, err
		case <-time.After(receiveTimeout):
			return StopVirtualCamResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r StopVirtualCamRequest) SendReceive(c Client) (StopVirtualCamResponse, error) {
	if err := r.Send(c); err != nil {
		return StopVirtualCamResponse{}, err
	}
	return r.Receive()
}

// StopVirtualCamResponse : Response for StopVirtualCamRequest.
//
// Since obs-websocket version: 4.9.1.
//
// https://github.com/Palakis/obs-websocket/blob/4.x-current/docs/generated/protocol.md#stopvirtualcam
type StopVirtualCamResponse struct {
	_response `json:",squash"`
}
